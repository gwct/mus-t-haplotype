---
title: "Mus chr17 window trees"
author: "[gwct](https://gwct.github.io/)"
date: "`r format(Sys.time(), '%m/%d/%Y %H:%M:%S %Z')`"
output:
  #html_document:
  rmdformats::robobook:
    highlight: kate
    includes:
      in_header: '../html-chunks/rmd_header.html'
    df_print: paged
    code_folding: hide
    number_sections: true
    toc_depth: 3
---

```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

#library(ggplot2)
library(tidyverse)
library(cowplot)
library(ggsignif)
library(here)
library("ggtree")
library(eulerr)
source(here("docs", "scripts", "lib", "design.r"))

total_spec = 6

window_size = 10
# Window size in kb

max_tree_rank = 3

```

From the cactus alignment HAL format, we converted to MAF using mm10 as the reference genome (for coordinate system) and then extracted 10kb windows across the scaffold in FASTA format. We then used IQ-tree to infer phylogenies for each window (after some filtering) and examined the frequency and distributions of topologies recovered.

```{r read-windows, out.width="50%", fig.align = "center", warning=FALSE}

infile = here("data", paste0("mm10-", window_size, "kb-topo-counts.csv"))
all_windows = read.csv(infile, header=T, comment.char="#")
all_windows = all_windows[order(-all_windows$end), ]
all_windows_f = subset(all_windows, filter=="PASS")
# Window trees file

aln_stats_file = here("data", paste0("mm10-", window_size, "kb-window-stats.tsv"))
aln_stats = read.csv(aln_stats_file, header=T, comment.char="#", sep="\t")
aln_stats$window <- gsub('.noanc', '', aln_stats$window)
# Window alignment stats

spec_counts_file = here("data", paste0("mm10-", window_size, "kb-spec-counts.tsv"))
spec_counts = read.csv(spec_counts_file, header=F, sep="\t")
names(spec_counts) = c("spec", "count")
# Window spec counts

```

# Alignment filtering

Note the filtering of alignment sites for gappiness precedes these steps. See [Window stats](https://gwct.github.io/mus-t-haplotype/windows.html) for more info.

In addition to the filtering of windows listed below, we could add an additional filter for **alignment length**. For example, we could filter out windows that are shorter than 100bp after removing gappy sites (which would exclude 74 more windows). Here is a distribution of alignment lengths after the gappy site filtering. Let me know if we should try this.

```{r aln-len-dist, out.width="50%", fig.align = "center", warning=FALSE}

p = ggplot(aln_stats, aes(x=aln.len.filter)) +
  geom_histogram(bins=30, color="#999999", fill=corecol(numcol=1, offset=7)) +
  scale_y_continuous(expand=c(0, 0)) +
  xlab("Post-filter alignment length") + 
  ylab("# of windows") +
  bartheme()
print(p)

```

# Window filtering

We then filtered some windows based on the following criteria:

1. All 6 species must be present in that window in the alignment ("Presence")
2. At least 4 of the sequences must be unique ("Unique")
3. No sequences can be comprised of all missing or gap characters ("Missing")

These filters break down as follows

```{r filter-venn, out.width="50%", fig.align = "center", warning=FALSE}

presence = aln_stats %>% filter(total.seqs.filter != 6)
unique_seqs = aln_stats %>% filter(uniq.seqs.filter < 4)
missing = aln_stats %>% filter(seqs.all.missing.gappy.filter != 0)

#filtered_windows = union(union(presence, unique_seqs), missing)$window
#filtered_trees = all_windows %>% filter(filter == "FILTER")
#other = aln_stats %>% filter(total.seqs.filter == 6 & uniq.seqs.filter >= 4 & sites.all.missing.gap != 0 & window %in% filtered_trees$window)

filters = list("Presence" = presence$window,
               "Unique"   = unique_seqs$window,
               "Missing"  = missing$window)

plot(euler(filters), quantities=T, fills=corecol(pal="wilke", numcol=3, offset=1))

print(paste0("WINDOWS BEFORE FILTERING: ", nrow(all_windows)))
print(paste0("WINDOWS AFTER  FILTERING: ", nrow(all_windows_f)))

spec_counts$missing = nrow(all_windows) - spec_counts$count

```

## Distribution of aligned sequences per window

The "Presence" filter

```{r filter-presence, out.width="50%", fig.align = "center", warning=FALSE}

p = ggplot(aln_stats, aes(x=total.seqs.filter)) +
  geom_histogram(stat="count", fill=corecol(numcol=1, offset=6)) +
  scale_x_continuous(breaks=1:6) +
  scale_y_continuous(expand=c(0, 0)) +
  xlab("Sequences") + 
  ylab("# of windows") +
  bartheme()
print(p)

```

```{r spec-counts, out.width="50%", fig.align = "center", warning=FALSE}

p = ggplot(spec_counts, aes(x=spec, y=missing)) +
  geom_bar(stat="identity", fill=corecol(pal="wilke", numcol=1, offset=6)) +
  #scale_x_continuous(breaks=1:6) +
  scale_y_continuous(expand=c(0, 0)) +
  xlab("") + 
  ylab("Missing in windows") +
  bartheme()
print(p)

```

# Distribution of tree topologies

Trees were inferred with IQ-tree across the unfiltered 10kb windows.

```{r tree-topo-dist, out.width="50%", fig.align = "center", warning=FALSE}

topo_counts = unique(subset(all_windows_f, select=c(topo.num.overall, topo.count.overall, topo.rank.overall, topo.color)))
topo_counts = topo_counts[order(topo_counts$topo.rank.overall),]
num_topos = nrow(topo_counts)
# Get the topology counts

print(paste0("In total ", num_topos, " different topologies were recovered"))

col_rank = 1
for(i in 1:nrow(topo_counts)){
  row = topo_counts[i,]
  cur_col = row$topo.color
  if(cur_col != "#999999"){
    new_label = paste("Top ", col_rank, sep="")
    col_rank = col_rank + 1
  }else{
    new_label = "Other"
  }
  topo_counts$col.cat[topo_counts$topo.num.overall==i] = new_label
  
  if(row$topo.rank.overall > max_tree_rank){
    topo_counts[i,]$topo.color = "#000000"
  }
}
# Add label and color columns to the topo counts

topo_counts$outline = "transparent"
# Add an outline column -- black outline is chrome topo

topo_counts$topo.prop = round(topo_counts$topo.count / sum(topo_counts$topo.count), 2)
# Percentage for each topology.

topo_counts_top = subset(topo_counts, topo.rank.overall <= 20)

bar_fills = as.character(topo_counts_top$topo.color)
names(bar_fills) = topo_counts_top$topo.rank.overall

fig_2a = ggplot(topo_counts_top, aes(x=reorder(topo.rank.overall, -topo.count.overall), y=topo.count.overall, fill=as.character(topo.rank.overall), color=outline, label=topo.prop)) +
  geom_bar(stat="identity", size=2) +
  geom_text(position=position_dodge(width=0.9), size=4, color="#333333", hjust=-0.15, vjust=-0.25, angle=45) +
  expand_limits(x = c(1,21)) +
  scale_y_continuous(expand=c(0, 0), limits=c(0,max(topo_counts$topo.count.overall)+1000)) +
  scale_fill_manual(name="", values=bar_fills) +
  scale_color_manual(name="", limits=topo_counts$outline, values=topo_counts$outline) +
  xlab("Topology rank") + 
  ylab("# of topologies") +
  bartheme() +
  theme(legend.position="none")
print(fig_2a)

```

# Most frequent topologies

```{r topos, out.width="75%", fig.align = "center", warning=FALSE, fig.height=6}

top_topos = head(as.numeric(topo_counts$topo.rank.overall),11)
#top_topos = 1:11
# Get the top ranking topologies for this chrome

tree_figs = list()
# A list to hold the three tree figs in

for(j in 1:length(top_topos)){
  # Generate figures for each of the top 3 topos
  cur_topo = top_topos[j]
  cur_tree_raw = as.character(all_windows_f[all_windows_f$topo.rank.overall==cur_topo,]$topo[1])
  
  # cur_tree_raw = gsub("rdil", "R. dilectus", cur_tree_raw)
  # cur_tree_raw = gsub("gdol", "G. dolicurus", cur_tree_raw)
  # cur_tree_raw = gsub("mm10", "M. musculus", cur_tree_raw)
  # cur_tree_raw = gsub("pdel", "P. delectorum", cur_tree_raw)
  # cur_tree_raw = gsub("mnat", "M. natalensis", cur_tree_raw)
  # cur_tree_raw = gsub("hall", "H. alleni", cur_tree_raw)
  # cur_tree_raw = gsub("rsor", "R. soricoides", cur_tree_raw)
  
  cur_tree = read.tree(text=cur_tree_raw)
  #cur_color_cat = topo_counts$col.cat[topo_counts$topo.rank.overall==cur_topo]
  #cur_color_ind = which(cur_color_cat == bar_labels)
  cur_color = as.character(topo_counts$topo.color[topo_counts$topo.rank.overall==cur_topo])
  # Get all info for the current topo (color, string, etc.)
  
  #nodecheck(cur_tree, tree_type="object", xmax=10)
  
  cur_fig = ggtree(cur_tree, size=1, ladderize=T) + 
    xlim_tree(7) + 
    ggplot2::ylim(0, 7) +
    ggplot2::xlim(0, 8) +
    geom_tiplab(color="#333333", fontface='italic', size=4) +
    theme(plot.margin = unit(c(0,1,0,0), "cm")) +
    #theme_tree2() + 
    theme(panel.border=element_rect(color=cur_color, fill="NA", size=3))
  #print(cur_fig)
  # Generate the tree
  
  tree_figs[[j]] = cur_fig
  # Save the tree fig in th elist
}

fig_2b = plot_grid(plotlist=tree_figs, nrow=4, ncol=3, labels=1:11, label_size=14, hjust=-1, align="vh")
print(fig_2b)

```

# Chromoplot

The distribution of topologies (and filtered windows in grey) across the chromosome

```{r gen-chromoplot, out.width="65%", fig.align = "center", warning=FALSE, fig.height=4}

chrome_to_plot = "17"
chrome_str = paste("chr", chrome_to_plot, sep="")
chrdata = subset(all_windows, chr==chrome_str)
total_windows = length(chrdata[,1])
chrdata_f = subset(all_windows_f, chr==chrome_str)
used_windows = length(chrdata_f[,1])
num_topos = max(chrdata_f$topo.num.chrome)

chr_len = chrdata[chrdata$chr==chrome_str, ]$chr.len[1]

chrdata$col.cat = NA
chrdata$ystart = NA
chrdata$yend = NA
cur_col = "#999999"
topo_counts$topo.color = as.character(topo_counts$topo.color)
for(i in 1:nrow(chrdata)) {
  cur_topo_num = chrdata[i,]$topo.num.overall
  if(aln_stats[aln_stats$window == chrdata[i,]$window,]$total.seqs.filter != 6){
    cur_col = "#999999"
    chrdata[i,]$ystart = 0
    chrdata[i,]$yend = 4
  }else if(is.na(cur_topo_num)){
    cur_col = "#ffffff"
    chrdata[i,]$ystart = 0
    chrdata[i,]$yend = 4
  }else{
    cur_col = topo_counts$topo.color[topo_counts$topo.num.overall==cur_topo_num]
    #print(cur_col)
  }
  chrdata[i,]$col.cat = cur_col
}

chrdata$ystart[chrdata$topo.rank.overall==1] = 4
chrdata$yend[chrdata$topo.rank.overall==1] = 3

chrdata$ystart[chrdata$topo.rank.overall==2] = 3
chrdata$yend[chrdata$topo.rank.overall==2] = 2

chrdata$ystart[chrdata$topo.rank.overall==3] = 2
chrdata$yend[chrdata$topo.rank.overall==3] = 1

chrdata$ystart[chrdata$topo.rank.overall>3] = 1
chrdata$yend[chrdata$topo.rank.overall>3] = 0
#chrdata$col.cat[chrdata$topo.rank.chrome>3] = "#999999"

cols_labs = levels(as.factor(chrdata$col.cat))
names(cols_labs) = levels(as.factor(chrdata$col.cat))

chr_breaks_5mb = seq(0,chr_len,by=5000000)
chr_labels_5mb = c()
first = TRUE
label_num = 1
for(i in chr_breaks_5mb){
  if(first){
    first = FALSE
    chr_labels_5mb = c(chr_labels_5mb, "")
    next
  }
  
  #label_str = paste0(label_num * 5, "Mb")
  chr_labels_5mb = c(chr_labels_5mb, label_num * 5)
  label_num = label_num + 1
}

```


```{r render-chromoplot, out.width="85%", fig.align = "center", warning=FALSE, fig.height=3}

fig_2c = ggplot(chrdata, aes(x=start, y=ystart, color=col.cat)) +
  geom_rect(aes(ymin=ystart, ymax=yend, xmin=start,xmax=end)) +
  #geom_segment(aes(x=start, y=ystart, xend=start, yend=yend)) +
  scale_color_manual(values=cols_labs) +
  scale_y_continuous(limits=c(0,4), breaks=0.5:3.5, labels=c("Other", "3", "2", "1")) +
  scale_x_continuous(limits=c(0,chr_len), breaks=chr_breaks_5mb, labels=chr_labels_5mb, expand=c(0,0)) +
  # geom_hline(yintercept=2,color="black") +
  ylab("Rank") +
  xlab("Position (Mb)") +
  ggtitle("Chromosome 17") +
  theme_classic() +
  theme(axis.title.x=element_text(size=12),
        axis.text.x = element_text(size=10),#, angle=25, vjust=1, hjust=1),
        axis.text.y=element_text(size=14),
        axis.title.y=element_text(size=16, angle=0, vjust=0.5),
        axis.line.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position="none",
        legend.key.width = unit(0.75,  unit = "cm"),
        legend.spacing.x = unit(0.25, 'cm'),
        legend.title = element_blank(),
        legend.text=element_text(size=12),
        plot.title = element_text(hjust=0.5, size=16),
        plot.margin = unit(c(0,1,0,0), "cm")
  )
print(fig_2c)

```




